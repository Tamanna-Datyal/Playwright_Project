"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.CucumberJSAllureFormatter = exports.CucumberJSAllureFormatterConfig = exports.Allure = void 0;
const cucumber_1 = require("@cucumber/cucumber");
const messages = __importStar(require("@cucumber/messages"));
const messages_1 = require("@cucumber/messages");
const allure_js_commons_1 = require("allure-js-commons");
const CucumberAllureInterface_1 = require("./CucumberAllureInterface");
var allure_js_commons_2 = require("allure-js-commons");
Object.defineProperty(exports, "Allure", { enumerable: true, get: function () { return allure_js_commons_2.Allure; } });
class CucumberJSAllureFormatterConfig {
}
exports.CucumberJSAllureFormatterConfig = CucumberJSAllureFormatterConfig;
class CucumberJSAllureFormatter extends cucumber_1.Formatter {
    constructor(options, allureRuntime, config) {
        super(options);
        this.allureRuntime = allureRuntime;
        this.currentAfter = null;
        this.currentBefore = null;
        this.currentGroup = null;
        this.currentTest = null;
        this.stepStack = [];
        this.documentMap = new Map();
        this.featureMap = new Map();
        this.scenarioMap = new Map();
        this.stepMap = new Map();
        this.testStepMap = new Map();
        this.pickleStepMap = new Map();
        this.stepDefinitionMap = new Map();
        this.testCaseTestStepsResults = new Map();
        this.pickleMap = new Map();
        this.hookMap = new Map();
        this.sourceMap = new Map();
        this.testCaseMap = new Map();
        this.testCaseStartedMap = new Map();
        this.allureSteps = new Map();
        this.convertStatus = (status) => {
            switch (status) {
                case messages_1.TestStepResultStatus.FAILED:
                    return allure_js_commons_1.Status.FAILED;
                case messages_1.TestStepResultStatus.PASSED:
                    return allure_js_commons_1.Status.PASSED;
                case messages_1.TestStepResultStatus.SKIPPED:
                case messages_1.TestStepResultStatus.PENDING:
                    return allure_js_commons_1.Status.SKIPPED;
                default:
                    return undefined;
            }
        };
        options.eventBroadcaster.on("envelope", this.parseEnvelope.bind(this));
        this.labels = config.labels || {};
        this.links = config.links || {};
        this.exceptionFormatter = (message) => {
            if (config.exceptionFormatter !== undefined) {
                try {
                    return config.exceptionFormatter(message);
                }
                catch (e) {
                    console.warn(`Error in exceptionFormatter: ${e}`);
                }
            }
            return message;
        };
        this.allureInterface = new CucumberAllureInterface_1.CucumberAllureInterface(this, this.allureRuntime);
        options.supportCodeLibrary.World.prototype.allure = this.allureInterface;
        this.beforeHooks = options.supportCodeLibrary.beforeTestCaseHookDefinitions;
        this.afterHooks = options.supportCodeLibrary.afterTestCaseHookDefinitions;
    }
    parseEnvelope(envelope) {
        if (envelope.gherkinDocument) {
            this.onGherkinDocument(envelope.gherkinDocument);
        }
        else if (envelope.pickle) {
            this.onPickle(envelope.pickle);
        }
        else if (envelope.testCase) {
            this.onTestCase(envelope.testCase);
        }
        else if (envelope.testCaseStarted) {
            this.onTestCaseStarted(envelope.testCaseStarted);
        }
        else if (envelope.testCaseFinished) {
            this.onTestCaseFinished(envelope.testCaseFinished);
        }
        else if (envelope.attachment) {
            this.onAttachment(envelope.attachment);
        }
        else if (envelope.hook) {
            this.onHook(envelope.hook);
        }
        else if (envelope.source) {
            this.onSource(envelope.source);
        }
        else if (envelope.testStepStarted) {
            this.onTestStepStarted(envelope.testStepStarted);
        }
        else if (envelope.testStepFinished) {
            this.onTestStepFinished(envelope.testStepFinished);
        }
    }
    onGherkinDocument(data) {
        var _a, _b;
        if (data.uri) {
            this.documentMap.set(data.uri, data);
        }
        (_b = (_a = data === null || data === void 0 ? void 0 : data.feature) === null || _a === void 0 ? void 0 : _a.children) === null || _b === void 0 ? void 0 : _b.forEach((fc) => {
            if (fc.scenario) {
                this.onScenario(fc.scenario);
            }
        });
    }
    onScenario(data) {
        this.scenarioMap.set(data.id, data);
        data.steps.forEach((step) => this.stepMap.set(step.id, step));
    }
    onPickle(data) {
        this.pickleMap.set(data.id, data);
        data.steps.forEach((ps) => this.pickleStepMap.set(ps.id, ps));
    }
    onTestCase(data) {
        this.testCaseMap.set(data.id, data);
        data.testSteps.forEach((ts) => this.testStepMap.set(ts.id, ts));
    }
    onTestCaseStarted(data) {
        const testCase = this.testCaseMap.get(data.testCaseId);
        if (!testCase) {
            console.error("onTestCaseStarted", "test case not found", data);
            return;
        }
        const pickle = this.pickleMap.get(testCase.pickleId);
        if (!pickle) {
            console.error("onTestCaseStarted", "pickle not found", data);
            return;
        }
        this.testCaseStartedMap.set(data.id, data);
        this.testCaseTestStepsResults.set(data.id, []);
        this.currentTest = new allure_js_commons_1.AllureTest(this.allureRuntime, Date.now());
        this.currentTest.name = pickle.name;
    }
    onAttachment(data) {
        console.log("onAttachment", data);
    }
    onTestCaseFinished(data) {
        if (!this.currentTest) {
            console.error("onTestCaseFinished", "current test not found", data);
            return;
        }
        const testCaseStarted = this.testCaseStartedMap.get(data.testCaseStartedId);
        if (!testCaseStarted) {
            console.error("onTestCaseFinished", "testCaseStarted event not found", data);
            return;
        }
        const testCase = this.testCaseMap.get(testCaseStarted.testCaseId);
        if (!testCase) {
            console.error("onTestCaseFinished", "testCase not found", data);
            return;
        }
        const pickle = this.pickleMap.get(testCase.pickleId);
        if (!pickle) {
            console.error("onTestCaseFinished", "pickle not found", data);
            return;
        }
        const testStepResults = this.testCaseTestStepsResults.get(testCaseStarted.id);
        if (testStepResults === null || testStepResults === void 0 ? void 0 : testStepResults.length) {
            const worstTestStepResult = messages.getWorstTestStepResult(testStepResults);
            this.currentTest.status = this.convertStatus(worstTestStepResult.status);
            this.currentTest.statusDetails = {
                message: worstTestStepResult.message,
            };
        }
        else {
            this.currentTest.status = allure_js_commons_1.Status.PASSED;
        }
        this.currentTest.endTest(Date.now());
    }
    onHook(data) {
        this.hookMap.set(data.id, data);
    }
    onSource(data) {
        if (data.uri) {
            this.sourceMap.set(data.uri, data);
        }
    }
    onTestStepStarted(data) {
        if (!this.currentTest) {
            return;
        }
        const testStep = this.testStepMap.get(data.testStepId);
        if (!testStep) {
            console.error("onTestStepStarted", "can't find step", data);
            return;
        }
        if (testStep.pickleStepId) {
            const ps = this.pickleStepMap.get(testStep.pickleStepId);
            if (!ps) {
                return;
            }
            const keyword = ps.astNodeIds
                .map((astNodeId) => this.stepMap.get(astNodeId))
                .map((step) => step === null || step === void 0 ? void 0 : step.keyword)
                .find((kw) => kw !== undefined) || "";
            const allureStep = this.currentTest.startStep(keyword + ps.text, Date.now());
            this.allureSteps.set(data.testStepId, allureStep);
        }
    }
    onTestStepFinished(data) {
        var _a;
        (_a = this.testCaseTestStepsResults.get(data.testCaseStartedId)) === null || _a === void 0 ? void 0 : _a.push(data.testStepResult);
        if (!this.currentTest) {
            return;
        }
        const allureStep = this.allureSteps.get(data.testStepId);
        if (!allureStep) {
            return;
        }
        allureStep.detailsMessage = data.testStepResult.message;
        allureStep.status = this.convertStatus(data.testStepResult.status);
        allureStep.endStep(Date.now());
    }
}
exports.CucumberJSAllureFormatter = CucumberJSAllureFormatter;
//# sourceMappingURL=CucumberJSAllureReporter.js.map